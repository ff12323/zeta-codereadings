é˜…è¯»ä»£ç ï¼š

 - ä»£ç çš„å¤æ‚åº¦ï¼šæœ‰äº›ä»£ç å…¶èƒŒåæ˜¯æ•°å­¦åŸç†çš„ä½“ç°ï¼Œè¦å½»åº•åœ°ç†è§£ä»£ç ï¼Œç­‰ä»·äºå½»åº•åœ°ç†è§£æ•°å­¦çš„åŸç†ã€‚åŸç†å¯å˜ï¼Œä»£ç ä¹Ÿå¯å˜ï¼Œå¤æ‚çš„æ•°é‡å¾ˆå¤šï¼Œä¹Ÿæ˜¯å›°éš¾çš„ä¸€ä¸ªå› ç´ ã€‚

é˜…è¯»åˆ†æ”¯ï¼š

- https://github.com/redis/redis/blob/7.4-rc1



## ch0 è®°å½•



æ¦‚å¿µçš„è®°å½•ï¼š

- äºŒï¼š
  - 2.1ï¼š
    - ã€Exported APIï¼Œå¤–éƒ¨APIã€‘
    - ã€Internal APIï¼Œå†…éƒ¨APIã€‘
- å››ï¼š
  - Internal functionï¼ˆå†…éƒ¨å‡½æ•°ï¼Œä¸æš´éœ²åœ¨å¤´æ–‡ä»¶ï¼‰



## ä¸€ã€commands.c

This file is auto generated by utils/generate-command-code.py, the content is based on the JSON files in the src/commands folder. These are meant to be the single source of truth about the Redis commands, and all the metadata about them. These JSON files are not meant to be used by anyone directly, instead that metadata can be obtained via the COMMAND command.


### 1ã€generate-command-code.py

ä¾èµ–ç³»ç»Ÿæ¨¡å—ã€glob --- Unix style pathname pattern expansionï¼ˆunixé£æ ¼è·¯å¾„æ¨¡å¼å±•å¼€ç¬¦ï¼‰ã€‘

main

 - åœ¨å½“å‰pyè„šæœ¬ä¸‹ï¼Œæ‰¾åˆ°ä»£ç ä»“åº“çš„srcç›®å½•çš„ç»å¯¹è·¯å¾„ï¼šé€šè¿‡`__file__`ï¼Œç»“åˆabspathä¸dirnameï¼Œè·å–å½“å‰æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•ï¼Œé€šè¿‡é¡¹ç›®çš„ç›®å½•ç»“æ„æ‹¼æ¥`/../src`å¾—åˆ°ã€‚
 - éå† src/commandsç›®å½•ä¸‹çš„jsonæ–‡ä»¶ã€‚
   - åŠ è½½jsonæ–‡ä»¶ï¼ˆè®¾è®¡æ ¼å¼ï¼šä¸€ä¸ªå‘½ä»¤key+å±æ€§ï¼‰
   - å¦‚æœå±æ€§ä¸­åŒ…å«containerï¼Œè¯´æ˜æ˜¯ä¸€ä¸ªå­å‘½ä»¤ã€‚
   - æ„é€ commandå¯¹è±¡ï¼šã€ã€‚ã€‚ã€‚ã€‘
 - æ‰“å¼€src/cmmand.defæ–‡ä»¶ï¼š
   - æŒ‰ç…§å›ºå®šæ ¼å¼ï¼Œæ¨¡æ¿ï¼Œéå†æ‰€æœ‰å‘½ä»¤ï¼Œå†™å…¥åˆ°æ–‡ä»¶ä¸­ã€‚
   - ã€ã€‚ã€‚ã€‚ã€‘
 - ã€ENDã€‘

## äºŒã€Radixæ ‘

### 2.1 ç»“æ„ä½“çš„å®šä¹‰

raxNodeï¼š

 - 32bitå›¾ï¼š
   - iskeyï¼šæœ¬èŠ‚ç‚¹æ˜¯å¦åŒ…å«keyï¼ˆè§æœ€åä¸€ä¸ªå­—æ®µï¼‰
   - isnullï¼šå…³è”çš„å€¼æ˜¯NULLï¼ˆNULLè¡¨ç¤ºï¼šåœ¨dataå¸ƒå±€çš„æ ¼å¼ä¸­ï¼Œå€¼ä¸æ˜¯ç›´æ¥æ”¾åœ¨å¤´éƒ¨ï¼Œè€Œæ˜¯åœ¨å°¾éƒ¨çš„æŒ‡é’ˆæ‰€æŒ‡å‘çš„åœ°æ–¹ï¼›ï¼‰
   - iscomprï¼šèŠ‚ç‚¹æ˜¯è¢«å‹ç¼©çš„
   - sizeï¼šå¦‚æœæ˜¯æœªå‹ç¼©çš„èŠ‚ç‚¹ï¼Œè¡¨ç¤ºçš„æ˜¯å­èŠ‚ç‚¹çš„ä¸ªæ•°;å¦‚æœæ˜¯å‹ç¼©çš„èŠ‚ç‚¹ï¼Œè¡¨ç¤ºå‹ç¼©çš„å­—ç¬¦ä¸²é•¿åº¦ã€‚
 - dataï¼šæŸ”æ€§æ•°ç»„ï¼Œå¸ƒå±€å…·ä½“çš„å†…å®¹ã€‚
   - æœªå‹ç¼©çš„ï¼šæ¯”å¦‚å­èŠ‚ç‚¹ä¸ªæ•°ä¸º3ï¼Œabcåˆ†åˆ«ä¸º3ä¸ªèŠ‚ç‚¹çš„å€¼ï¼Œåé¢æ˜¯3ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆï¼ˆæ ¼å¼ï¼š`[abc][a-ptr][b-ptr][c-ptr](value-ptr?)`ï¼‰
   - å‹ç¼©çš„ï¼šï¼ˆæ ¼å¼ï¼š`[xyz][z-ptr](value-ptr?)`ï¼‰
   - value-ptrï¼š å¦‚æœåŒ…å«key å¹¶ä¸” å€¼ä¸ä¸ºNULLï¼Œåˆ™å­˜åœ¨ã€‚


raxï¼šraxæ ‘ç»“æ„ä½“

 - *headï¼šæŒ‡å‘èµ·å§‹çš„raxèŠ‚ç‚¹ã€‚
 - numeleï¼š number elementï¼ˆå…ƒç´ ä¸ªæ•°ï¼Ÿï¼‰
 - numnodesï¼š è®°å½•èŠ‚ç‚¹çš„ä¸ªæ•°
 - metadataï¼šã€æŸ”æ€§æ•°ç»„ï¼Œï¼Ÿï¼Ÿï¼Ÿã€‘

raxStackï¼šæ ˆæ•°æ®ç»“æ„ï¼Œç”¨äºå¯é€‰åœ°è¿”å›è°ƒç”¨è€…çš„ä¸€ä¸ªçˆ¶äº²èŠ‚ç‚¹åˆ—è¡¨ï¼›raxèŠ‚ç‚¹å‡ºäºç©ºé—´å ç”¨è€ƒè™‘è€Œæ²¡æœ‰â€œçˆ¶äº²â€è¿™ä¸ªå­—æ®µã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨éœ€è¦çš„æ—¶å€™ï¼Œä½¿ç”¨è¿™ä¸ªè¾…åŠ©çš„æ ˆã€‚

 - stacksï¼šã€äºŒçº§æŒ‡é’ˆã€‘ï¼ˆï¼ŒæŒ‡å‘æœ¬ç»“æ„ä½“çš„static_itemså­—æ®µæˆ–è€…ä¸€ä¸ªå †ä¸Šåˆ†é…çš„æ•°ç»„ï¼‰Points to static_items or an heap allocated array.
 - items: è®°å½•åŒ…å«çš„ä¸ªæ•°ï¼ˆä½œç”¨ï¼šæ¸¸æ ‡ï¼ŒæŒ‡å‘æ ˆé¡¶ï¼‰
 - maxitemsï¼š æ€»ç©ºé—´çš„ä¸ªæ•°
 - static_items[32]ï¼ˆå®ï¼šRAX_STACK_STATIC_ITEMSï¼‰ï¼šé¿å…åœ¨å †ä¸Šè¿›è¡Œåˆ†é…ï¼Œä½¿ç”¨è¿™ä¸ªé™æ€æ•°ç»„æŒ‡é’ˆä½œä¸ºä»£æ›¿ã€‚
 - oom: ã€ï¼Ÿï¼Ÿï¼Ÿï¼Œè¿™ä¸ªæ˜¯ä»€ä¹ˆç°è±¡ã€‘True if pushing into this stack failed for OOM at some point.

raxèŠ‚ç‚¹å›è°ƒå‡½æ•°ï¼š

 - ç”¨äºè¿­ä»£å™¨çš„å¯é€‰é¡¹å›è°ƒå‡½æ•°ï¼Œåœ¨æ¯ä¸ªraxèŠ‚ç‚¹ä¸Šè¢«é€šçŸ¥ï¼Œä¿æŠ¤ä¸è¡¨ç¤ºkeysçš„èŠ‚ç‚¹ã€‚å¦‚æœå›è°ƒè¿”å›trueï¼Œåˆ™å›è°ƒæ”¹å˜äº†è¿­ä»£å™¨ç»“æ„ä½“çš„nodeå­—æ®µæŒ‡é’ˆï¼ˆï¼Œï¼Ÿï¼Ÿï¼Ÿï¼‰ä¸”è¿­ä»£å™¨çš„å®ç°å°†ä¼šæ›¿æ¢radixæ ‘å†…éƒ¨çš„æŒ‡é’ˆã€‚è¿™ä¸ªå…è®¸å›è°ƒå»é‡åˆ†é…èŠ‚ç‚¹è€Œæ‰§è¡Œéå¸¸ç‰¹æ®Šçš„æ“ä½œã€‚ï¼ˆï¼Ÿï¼Ÿï¼Ÿï¼Œä»€ä¹ˆæ“ä½œï¼Ÿï¼‰ï¼Œå¸¸è§„çš„åº”ç”¨é€šå¸¸æ˜¯ä¸éœ€è¦çš„ã€‚
 - ç”¨äºå¯¹radixæ ‘ç»“æ„ä½“æ‰§è¡Œéå¸¸ä½å±‚çº§åˆ†æï¼Œæ‰«ææ¯ä¸ªå¯èƒ½çš„èŠ‚ç‚¹ï¼ˆé™¤äº†æ ¹èŠ‚ç‚¹ï¼‰ï¼Œæˆ–ä¸ºäº†é‡åˆ†é…èŠ‚ç‚¹è€Œå‡å°‘**åˆ†é…ç¢ç‰‡åŒ–ï¼ˆallocation fragmentationï¼‰** ï¼ˆï¼Ÿï¼šå¦‚ä½•è§‚æµ‹ï¼‰ã€‚ã€‚ã€‚
 - å½“å‰åªæ”¯æŒå‰å‘è¿­ä»£ã€‚ã€‚

```c
/* Optional callback used for iterators and be notified on each rax node,
 * including nodes not representing keys. If the callback returns true
 * the callback changed the node pointer in the iterator structure, and the
 * iterator implementation will have to replace the pointer in the radix tree
 * internals. This allows the callback to reallocate the node to perform
 * very special operations, normally not needed by normal applications.
 *
 * This callback is used to perform very low level analysis of the radix tree
 * structure, scanning each possible node (but the root node), or in order to
 * reallocate the nodes to reduce the allocation fragmentation (this is the
 * Redis application for this callback).
 *
 * This is currently only supported in forward iterations (raxNext) */
typedef int (*raxNodeCallback)(raxNode **noderef);
```

raxIteratorï¼šraxæ ‘çš„è¿­ä»£å™¨

 - flagsï¼šé€šè¿‡bitä½æ¥æ ‡è®°è¿­ä»£å™¨çš„å½“å‰çŠ¶æ€
   - `RAX_ITER_JUST_SEEKED`ï¼šIterator was just seeked. Return current element for the first iteration and clear the flag.
   - `RAX_ITER_EOF`ï¼šï¼ˆåˆ°è¾¾è¿­ä»£çš„ç»ˆç‚¹ï¼‰End of iteration reached.
   - `RAX_ITER_SAFE`ï¼šSafe iterator, allows operations while iterating. But it is slower.
 - rtï¼šï¼ˆï¼ŒæŒ‡å‘è¿›è¡Œè¿­ä»£çš„Radixæ ‘ï¼‰Radix tree we are iterating.
 - keyï¼š ã€ï¼Ÿï¼Ÿï¼Ÿã€‘The current string.
   - æ³¨ï¼šå¦‚æ­Œkeyçš„é•¿åº¦å°äº128ï¼Œåˆ™æ”¾åœ¨å½“å‰çš„ç»“æ„ä½“å†…éƒ¨ã€‚å¦åˆ™ï¼Œåœ¨å †ä¸ŠæŒ‰ç…§2è¢«å¤§å°æ‰©å¼ ã€‚
 - dataï¼š ã€ï¼Ÿï¼Ÿï¼Ÿã€‘Data associated to this key.
 - key_lenï¼šï¼ˆï¼Œå½“å‰keyçš„é•¿åº¦ï¼‰Current key length.
 - key_maxï¼šï¼ˆï¼Œå½“å‰çš„keyç¼“å†²åŒºå¯ä»¥æŒæœ‰çš„æœ€å¤§keyé•¿åº¦ï¼‰Max key len the current key buffer can hold. 
 -  key_static_string[128ï¼ˆå®ï¼š`RAX_ITER_STATIC_LEN`ï¼‰]ï¼š  key buffer
 - nodeï¼šï¼ˆï¼Ÿï¼Ÿï¼Ÿï¼‰Current node. Only for unsafe iteration.
 - stackï¼šï¼ˆï¼Œraxæ ˆï¼Œç”¨äºä¸å®‰å…¨çš„è¿­ä»£ï¼›ï¼Ÿï¼Ÿä»€ä¹ˆæ˜¯ä¸å®‰å…¨çš„ï¼Ÿï¼‰Stack used for unsafe iteration.
 - node_cbï¼šï¼ˆï¼Œå‡½æ•°æŒ‡é’ˆï¼Œå¯é€‰é¡¹çš„èŠ‚ç‚¹å›è°ƒå‡½æ•°ï¼›ï¼‰Optional node callback. Normally set to NULL.

ã€Exported APIï¼Œå¤–éƒ¨APIã€‘

 - å‘½åè§„èŒƒï¼šç»Ÿä¸€ä»¥ raxXXXçš„æ ¼å¼ã€‚

ã€Internal APIï¼Œå†…éƒ¨APIã€‘

 - ï¼ˆï¼Œå¯èƒ½ä¼šè¢«èŠ‚ç‚¹çš„å›è°ƒä½¿ç”¨ï¼Œä¸ºäº†ä»¥**ä½å±‚çº§çš„æ–¹å¼**è®¿é—®raxèŠ‚ç‚¹ï¼›æ‰€ä»¥è¿™ä¸ªå‡½æ•°ä¹Ÿè¢«æš´éœ²ã€‚ï¼‰May be used by the node callback in order to access rax nodes in a low level way, so this function is exported as well.


### 2.2 raxå†…å­˜åˆ†é…å™¨

éœ€è¦æ”¹ä»£ç ï¼Œæ¥æ”¹åˆ†é…å™¨ã€‚
rax_malloc.h

 - Allocator selection.ï¼ˆåˆ†é…å™¨é€‰æ‹©ï¼‰
 - ï¼ˆï¼Œä¸ºäº†åœ¨ç¼–è¯‘æ—¶æ”¹å˜Raxåˆ†é…å™¨ã€‚ã€‚ã€‚ã€‚ï¼‰This file is used in order to change the Rax allocator at compile time. Just define the following defines to what you want to use. Also add the include of your alternate allocator if needed (not needed in order to use the default libc allocator).

```c
#define rax_malloc zmalloc
#define rax_realloc zrealloc
#define rax_free zfree
```

### 2.3 ï¼ˆâŒï¼‰radixæ ‘å®ç°

raxStackPushï¼š

 - å¦‚æœé¡¹çš„ä¸ªæ•° ç­‰äº æœ€å¤§ä¸ªæ•°ï¼Œè¯´æ˜å·²ç»æ»¡äº†ï¼Œéœ€è¦æ‰©å¤§ç©ºé—´ã€‚
   - å¦‚æœæ ˆæŒ‡å‘é™æ€æ•°ç»„å­—æ®µ
     - mallocåˆ†é…2å€å¤§å°çš„ç©ºé—´
     - å°†åˆ†é…çš„åœ°å€è®¾ç½®åˆ°stackå­—æ®µ
     - å¦‚æœåˆ†é…å¤±è´¥ï¼Œæ¢å¤ï¼Œè®¾ç½®oomï¼Œerrnoï¼Œè¿”ERR
   - å¦åˆ™ï¼Œæ ˆæŒ‡å‘å †ç©ºé—´
     - æŒ‰ç…§åŸå¤§å°çš„2å€ï¼Œrealloc
     - å¦‚æœåˆ†é…å¤±è´¥ï¼ŒåŒä¸Šã€‚
     - è®¾ç½®æ–°åœ°å€åˆ°æ ˆå­—æ®µ
   - æœ€å¤§ä¸ªæ•°å­—æ®µè®¾ç½®ä¸ºåŸæ¥çš„2å€ã€‚
 - åœ¨æ ˆé¡¶æ’å…¥æ–°çš„é¡¹ï¼Œæ›´æ–°æ ˆé¡¶æŒ‡é’ˆï¼ˆä¸ªæ•°ï¼‰è¿”OK

```
raxStackPush
 Ds: å°†é¡¹å…¥æ ˆ
 ret:
  1: æˆåŠŸ
  0: OOM å¤±è´¥

```

#### 1ã€åˆ†é…raxèŠ‚ç‚¹

raxPadding: å¯¹äºå­—ç¬¦å°èŠ‚å¤§å°ä¸ºnodeSizeï¼Œä¸ºäº†ä½¿åé¢å­˜æ”¾å­èŠ‚ç‚¹çš„æŒ‡é’ˆæ˜¯åœ¨å¯¹é½åœ°å€ä¸Šçš„ï¼ˆaligned addressï¼‰ã€‚æ³¨æ„ï¼š+4ï¼Œæ˜¯å› ä¸ºç»“æ„ä½“å¤´éƒ¨æ˜¯4å­—èŠ‚çš„ã€‚

```c
/* Return the padding needed in the characters section of a node having size
 * 'nodesize'. The padding is needed to store the child pointers to aligned
 * addresses. Note that we add 4 to the node size because the node has a four
 * bytes header. */
#define raxPadding(nodesize) ((sizeof(void*)-(((nodesize)+4) % sizeof(void*))) & (sizeof(void*)-1))
```

ç¦»æ•£å‘¨æœŸå‡½æ•°ï¼šé€šè¿‡wolframalphaç”»å›¾ï¼Œå¯ä»¥ç›´è§‚åœ°çœ‹åˆ°ã€‚

```
discrete plot BitAnd[8 - Mod[(x+4), 8], 8-1] from x=0 to x=25

```

ç­‰ä»·å½¢å¼ï¼š

```
discrete plot BitAnd[Mod[8-(x+4), 8], 8-1] from x=0 to x=25
discrete plot BitAnd[Mod[z-(x+4), z], z-1] for z=4 or 8 from x=0 to x=25

Mod[z-(x+4), z]
```

ç”±æ­¤å¯å¾—å…¶ç­‰ä»·å½¢å¼æ˜¯ï¼š

```c
#define raxPadding(nodesize) ((sizeof(void*) - (nodesize+4)) % sizeof(void*))
```

#### 1ã€å·¥å…·å®

raxNodeCurrentLengthï¼šè¿”å›radixèŠ‚ç‚¹çš„çœŸå®å¤§å°ï¼ˆæ”¯æŒå‹ç¼©ã€éå‹ç¼©ï¼‰

 - è®¡ç®—æ ¼å¼ï¼š`[header iscompr=0][abc][a-ptr][b-ptr][c-ptr](value-ptr?)`

raxNodeLastChildPtrï¼šè¿”å›radixèŠ‚ç‚¹æŒ‡å‘çš„æœ€åä¸€ä¸ªå­èŠ‚ç‚¹æŒ‡é’ˆçš„äºŒçº§æŒ‡é’ˆ

 - å…¬å¼ = nodeåœ°å€ + nodeçœŸå®å¤§å° - value-ptrå¤§å°ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ - nodeæŒ‡é’ˆå¤§å°

raxNodeFirstChildPtrï¼šæŒ‡å‘radixèŠ‚ç‚¹æŒ‡å‘çš„ç¬¬ä¸€ä¸ª


---

node auxiliary dataï¼š

 - é—®é¢˜ï¼švalue-ptrçš„å¤§å°æ˜¯`void *`ï¼Œä½†æ˜¯åœ¨getDataã€setDataä¸­ï¼Œéœ€è¦å°†å…¶å¼ºè½¬ä¸º `void**` ï¼Ÿï¼Ÿï¼Ÿ
 - è‡ªç­”ï¼š è¦ç†è§£è¿™ä¸ªæ“ä½œï¼Œå…ˆæ€è€ƒä¸‹ `n->i = 10`ï¼Œè¿™ç§ç»“æ„ä½“æŒ‡é’ˆèµ‹å€¼æ“ä½œã€‚å…¶å…·ä½“æ˜¯å¦‚ä½•å®ç°çš„å‘¢ï¼Ÿï¼ˆçŒœæµ‹ï¼šæœ¬è´¨ä¸Šæ˜¯å–å¾—å­—æ®µçš„å†…å­˜åœ°å€ï¼Œå†memcpyè®¾ç½®å†…å­˜å®Œæˆã€‚ï¼‰è€Œåœ¨è¿™é‡Œï¼Œç”±äºæŸ”æ€§æ•°ç»„çš„å­å­—æ®µæ˜¯ä¸€ä¸ª`void *`,memcpyéœ€è¦é€šè¿‡dataçš„æŒ‡é’ˆå®Œæˆã€‚ç”±æ­¤è½¬ä¸ºäºŒçº§æŒ‡é’ˆ

#### 2ã€æ·»åŠ å­èŠ‚ç‚¹

raxAddChild

 - è®¡ç®—æ—§èŠ‚ç‚¹ä¸æ–°èŠ‚ç‚¹çš„æ€»é•¿åº¦ã€‚
 - åˆ†é…ä¸€ä¸ªraxæ ‘å­èŠ‚ç‚¹ï¼Œå¤±è´¥è¿”NULL
 - æ ¹æ®æ–°é•¿åº¦å¯¹nè¿›è¡Œrealloc
 - éå†å­—ç¬¦åŒºï¼ŒæŒ‰ç…§å­—æ¯è¡¨é¡ºåºæŸ¥æ‰¾æ’å…¥ä½ç½®pos(åœ¨ä¸‹é¢å†…å­˜ç§»åŠ¨æ˜¯ç¬¬ä¸€ä¸ªç§»åŠ¨çš„ä½ç½®)ã€‚
 - å¦‚æœå­˜åœ¨auxiliary data pointerï¼Œå°†å…¶ç§»åŠ¨åˆ°æ–°èŠ‚ç‚¹çš„æœ€å
 - è®¡ç®—shiftåç§»ï¼ˆæ–°æ—§é•¿åº¦ä¹‹å·® - å•ä¸ªæŒ‡é’ˆæŒ‡é’ˆé•¿åº¦ï¼‰
   - å¦‚æœå¯ä»¥ä½¿ç”¨å·²æœ‰çš„paddingï¼Œåˆ™shiftä¸º0ï¼Œå¦åˆ™éœ€è¦æ–°å¢åˆ™ä¸º1ã€‚
 - 1ã€é€šè¿‡memmoveå°†posä¹‹åçš„æŒ‡é’ˆæ®µï¼Œå‘åç§»åŠ¨åˆ°è¾…åŠ©ä¹‹å‰ã€‚
 - 2ã€å¦‚æœéœ€è¦shiftï¼šæ‰¾åˆ°ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹æŒ‡é’ˆçš„ä½ç½®ï¼Œå°†å…¶åçš„posä¸ªä½ç½®å‘åç§»åŠ¨shifté•¿åº¦ã€‚
 - 3ã€ç§»åŠ¨å­—ç¬¦åŒºåŸŸï¼Œä»poså¼€å§‹å‘åç§»åŠ¨1ä¸ªbyte
 - èµ‹å€¼ï¼Œè®¾ç½®è¾“å‡ºå‚æ•°ï¼Œè¿”å›æ–°çš„n
 - ä¾‹å­ï¼šä»¥32ä½æœºå™¨/4å­—èŠ‚
   - å†…å­˜ç»“æ„ï¼š`[HDR*][abde][Aptr][Bptr][Dptr][Eptr]|AUXP|`ï¼Œæ–°å¢å­—æ¯cçš„å­èŠ‚ç‚¹
   - reallocä¹‹åçš„ç»“æ„ï¼š `[HDR*][abde][Aptr][Bptr][Dptr][Eptr]|AUXP|[....][....]`
   - ç§»åŠ¨è¾…åŠ©æ•°æ®æŒ‡é’ˆï¼š`[HDR*][abde][Aptr][Bptr][Dptr][Eptr][....][....]|AUXP|`
   - ç¬¬ä¸€æ¬¡åç§»ï¼š`[HDR*][abde][Aptr][Bptr][....][....][Dptr][Eptr]|AUXP|`
   - ç¬¬äºŒæ¬¡åç§»ï¼š`[HDR*][abde][....][Aptr][Bptr][....][Dptr][Eptr]|AUXP|`
   - ç¬¬3æ¬¡åç§»ï¼š `[HDR*][ab.d][e...][Aptr][Bptr][....][Dptr][Eptr]|AUXP|`
   - è®¾ç½®æ’å…¥çš„å€¼ï¼š`[HDR*][abcd][e...][Aptr][Bptr][Cptr][Dptr][Eptr]|AUXP|`

```
raxAddChild:
  Ds: å‘ä¸€ä¸ªèŠ‚ç‚¹æ·»åŠ å­èŠ‚ç‚¹
  Paraï¼š
   n: çˆ¶èŠ‚ç‚¹ï¼Œåœ¨å…¶ä¸Šé¢æ–°å¢å­èŠ‚ç‚¹
   cï¼šè¡¨ç¤ºå­èŠ‚ç‚¹çš„å­—ç¬¦
   childptrï¼šã€outã€‘äºŒçº§æŒ‡é’ˆï¼Œå°†æ–°åˆ†é…çš„å­èŠ‚ç‚¹çš„åœ°å€ï¼Œä¿®æ”¹å‚æ•°ï¼ˆä¸€çº§æŒ‡é’ˆï¼‰å€¼ã€‚
   parentlinkï¼šã€outã€‘ä¸‰çº§æŒ‡é’ˆï¼Œåœ¨çˆ¶èŠ‚ç‚¹çš„æ•°æ®æ®µçš„å­˜æ”¾å­èŠ‚ç‚¹æŒ‡é’ˆçš„ä½ç½®ï¼ˆæŒ‡é’ˆï¼‰ï¼Œä¿®æ”¹å‚æ•°ï¼ˆäºŒçº§æŒ‡é’ˆï¼‰å€¼
  Ret: æ–°çš„çˆ¶èŠ‚ç‚¹æŒ‡é’ˆï¼ˆå¯èƒ½è¿›è¡Œreallocï¼Œé‡æ–°åˆ†é…ï¼‰
   NULLï¼šOOMï¼Œåˆ†é…å¤±è´¥
```

---

raxCompressNode

 - åˆ†é…ä¸€ä¸ªç©ºå†…å®¹çš„å­èŠ‚ç‚¹
 - è®¡ç®—å‹ç¼©åçš„èŠ‚ç‚¹é•¿åº¦ = å¤´éƒ¨ + å­—ç¬¦ä¸² + å¯¹é½ + å•ä¸ªå­èŠ‚ç‚¹æŒ‡é’ˆ
 - realloc
 - è®¾ç½®èŠ‚ç‚¹çš„ç±»å‹ä¸ºå·²å‹ç¼©ã€‚
 - è®¾ç½®èŠ‚ç‚¹çš„å„ä¸ªå±æ€§ï¼ˆã€‚ã€‚ã€‚ï¼‰

```
raxCompressNode:
  Ds: å¯¹ä¸€ä¸ªæœªå‹ç¼©çš„èŠ‚ç‚¹ï¼ˆä¸èƒ½å­˜åœ¨å­èŠ‚ç‚¹ï¼‰è¿›è¡Œå‹ç¼©å¤„ç†ã€‚ä½¿å¾—æ ‘çš„æŸä¸ªåˆ†é’Ÿï¼Œè¿ç»­å¤šä¸ªè¡¨ç¤ºå•å­—ç¬¦çš„å­èŠ‚ç‚¹ï¼Œè¢«å‹ç¼©æˆè¡¨ç¤ºä¸€ä¸ªå­—ç¬¦ä¸²çš„å•èŠ‚ç‚¹ã€‚
  Para:
   nï¼šè¢«å‹ç¼©çš„èŠ‚ç‚¹
   sï¼šå­—ç¬¦ä¸²æŒ‡é’ˆï¼Œå‹ç¼©åéœ€è¦è¡¨ç¤ºçš„å­—ç¬¦ä¸²
   lenï¼šå­—ç¬¦ä¸²é•¿åº¦
   childï¼šã€outã€‘äºŒçº§æŒ‡é’ˆï¼Œæ–°åˆ†é…çš„ï¼Œæ”¹å‚ã€‚
  Ret: æ–°çš„çˆ¶èŠ‚ç‚¹æŒ‡é’ˆï¼ˆå¯èƒ½è¿›è¡Œreallocï¼Œé‡æ–°åˆ†é…ï¼‰
```

#### 3ã€raxLowWalk

raxLowWalk

 - ä»å¤´éƒ¨èŠ‚ç‚¹å¼€å§‹
 - i è®°å½•å­—ç¬¦ä¸²éå†çš„ä½ç½®
 - j è®°å½•èŠ‚ç‚¹ä¸­å­èŠ‚ç‚¹çš„ä½ç½®
 - while å½“å‰èŠ‚ç‚¹çš„å¤§å°ä¸ä¸º0 ä¸” å­—ç¬¦ä¸²æœªéå†å®Œ
   - å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯å‹ç¼©çš„ï¼š
     - åŒä¸‹æ ‡å‰è¿›ï¼Œå¾ªç¯éå†å‹ç¼©èŠ‚ç‚¹çš„å­—ç¬¦èŠ‚ï¼Œå¦‚æœ2è€…å­—ç¬¦ä¸ç­‰ï¼Œbreaké€€å‡º
     - å¦‚æœå­—ç¬¦èŠ‚çš„ä¸‹æ ‡ï¼Œæ²¡æœ‰éå†åˆ°ç»ˆç‚¹ã€‚breaké€€å‡ºï¼ˆè¯´æ˜ï¼šåŒ¹é…çš„å­—ç¬¦è¿‡çŸ­è€Œç»“æŸï¼Œæˆ–åŒ¹é…ç»ˆæ­¢ï¼‰
   - å¦åˆ™ï¼Œä»å­—ç¬¦åŒºè¿›è¡Œçº¿æ€§æœç´¢ï¼ˆlinear searchï¼‰æŸ¥æ‰¾å­èŠ‚ç‚¹ä¸ä¸‹æ ‡å­—ç¬¦ç›¸ç­‰çš„ã€‚
     - å¦‚æœ j ç­‰äº å­èŠ‚ç‚¹ä¸ªæ•°è¯´æ˜æœªæœç´¢åˆ°ã€‚breaké€€å‡ºï¼ˆè¯´æ˜ï¼šæ— æ³•åŒ¹é…ï¼‰
   - radixæ ˆè®°å½•å½“å‰èŠ‚ç‚¹
   - æ›´æ–°å½“å‰èŠ‚ç‚¹ä¸ºå¯¹åº”çš„å­èŠ‚ç‚¹ï¼ˆå‹ç¼©èŠ‚ç‚¹åªæœ‰1ä¸ªï¼‰
   - é‡ç½® j ä¸‹æ ‡ä¸º 0 ï¼ˆIf the new node is non compressed and we do not iterate again (since i == len) set the split position to 0 to signal this node represents the searched key.ï¼‰
   - ç•¥
   - è¿”å›ä¸‹æ ‡ iï¼Œè¡¨ç¤ºåŒ¹é…çš„é•¿åº¦

```
raxLowWalk:
  Ds: éå†ä¸€ä¸ªradixæ ‘ï¼Œ
   type: [low level function] ä½å±‚çº§å‡½æ•°
  Para:
   raxï¼šã€‚ã€‚ã€‚
   sï¼šåŒ¹é…çš„å­—ç¬¦ä¸²
   lenï¼šå­—ç¬¦ä¸²é•¿åº¦
   stopnodeï¼šã€outã€nullableã€‘åŒ¹é…ç»ˆæ­¢çš„radixèŠ‚ç‚¹
   plinkï¼šä¸‰ç»´æŒ‡é’ˆã€outã€nullableã€‘å¯¹äºç»ˆæ­¢èŠ‚ç‚¹å…¶çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆåŒºæ‰§è¡Œå…¶çš„äºŒç»´æŒ‡é’ˆåœ°å€
   splitposï¼šã€outã€nullableã€‘å¦‚æœç»ˆæ­¢èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå‹ç¼©èŠ‚ç‚¹ï¼Œä¸”å­—ç¬¦åŒ¹é…åœ¨å…¶ä¸Šé¢ä¸æ˜¯èŠ‚ç‚¹å®Œå…¨åŒ¹é…ï¼Œè€Œæ˜¯å…¶ä¸­ä¸€éƒ¨åˆ†ï¼Œéœ€è¦è®°å½•è¿™ä¸€éƒ¨åˆ†çš„ä¸‹æ ‡ï¼›ï¼ˆä¾‹å­ï¼š0ï¼Œè¡¨ç¤ºæ— éœ€å‹ç¼©èŠ‚ç‚¹çš„å­—ç¬¦ï¼Œå…¶å®ƒåˆ™éœ€è¦ä¸€éƒ¨åˆ†ï¼Œæœ€å¤§å€¼æ˜¯å­—ç¬¦èŠ‚çš„é•¿åº¦ï¼‰
      ç”¨é€”ï¼šåœ¨æ’å…¥æ—¶ï¼Œå¯¹äºç»ˆæ­¢èŠ‚ç‚¹å¯èƒ½å‡ºç°åˆ†è£‚çš„æƒ…å†µï¼Œéœ€è¦æ›¿æ¢ä¸ºæ–°çš„èŠ‚ç‚¹ã€‚è€Œéœ€è¦ä¿®æ­£çˆ¶èŠ‚ç‚¹å¯¹äºå­èŠ‚ç‚¹çš„å¼•ç”¨ï¼Œå°†è¿™é‡Œè®¾ç½®ä¸ºæ–°çš„å­èŠ‚ç‚¹ã€‚
   tsï¼šã€outã€nullableã€‘radixæ ˆï¼Œè®°å½•åŒ¹é…å­—ç¬¦ä¸²ç»è¿‡çš„radixæ ˆ
  Ret:

```

#### 4ã€æ’å…¥èŠ‚ç‚¹

raxGenericInsert

- è°ƒç”¨ raxLowWalkï¼Œå¯¹æ’å…¥çš„å…ƒç´ çš„è¿›è¡ŒåŒ¹é…ã€‚
- å¦‚æœï¼šåŒ¹é…çš„é•¿åº¦ç­‰äºæ’å…¥çš„é•¿åº¦ ä¸” ä¸åœ¨ä¸€ä¸ªå‹ç¼©èŠ‚ç‚¹çš„ä¸­é—´ä½ç½®ã€‚
  - å¦‚æœç»ˆæ­¢èŠ‚ç‚¹ä¸åŒ…å«key  æˆ– ï¼ˆå…³è”å€¼ä¸ºNULL ä¸” è¦†ç›–ï¼‰ï¼š
    - ã€ï¼Ÿï¼Ÿï¼Ÿã€‘è¯´æ˜ä¸å­˜åœ¨å…³è”å€¼çš„æŒ‡é’ˆç©ºé—´ï¼Œå¯¹èŠ‚ç‚¹reallocï¼Œå¹¶è®¾ç½®æ•°æ®æŒ‡é’ˆã€‚
      - OOMï¼Œè¿”0
    - æ ¹æ®walkéå†è¿”å›çš„çˆ¶èŠ‚ç‚¹dataå­˜æ”¾ä½ç½®ï¼Œæ›´æ–°ä¸ºæ–°çš„èŠ‚ç‚¹æŒ‡é’ˆã€‚
  - å¦‚æœæœ¬èŠ‚ç‚¹å­˜åœ¨keyï¼Œæ›´æ–°ä¹‹ï¼š
    - å­˜æ”¾æ—§çš„
    - å¦‚æœè¦†ç›–ï¼Œè®¾ç½®æ–°çš„ã€‚
    - è¿” 0
  - å°†èŠ‚ç‚¹è®¾ç½®ä¸ºå­˜åœ¨keyï¼Œè®¾ç½®æ•°æ®æŒ‡é’ˆã€‚
  - radixæ ‘å…ƒç´ ä¸ªæ•° ++
  - è¿”1
- ï¼ˆæ³¨é‡Šï¼šå¦‚æœèŠ‚ç‚¹ç»ˆæ­¢åœ¨ä¸€ä¸ªå‹ç¼©èŠ‚ç‚¹ä¸Šï¼Œæˆ‘ä»¬ç»§ç»­è¿›è¡Œä¸‹å»å‰ï¼Œéœ€è¦å°†è¿™ä¸ªèŠ‚ç‚¹**åˆ†è£‚**ï¼‰
  - ï¼ˆï¼Œåˆ†è£‚ä¸€ä¸ªå‹ç¼©èŠ‚ç‚¹æœ‰ç€ä¸€äº›å¯èƒ½çš„æƒ…å†µã€‚ï¼‰Splitting a compressed node have a few possible cases.
  - ä¾‹å­ï¼šå‡è®¾hæ˜¯ä¸€ä¸ªå‹ç¼©èŠ‚ç‚¹ï¼ŒåŒ…å«å­—ç¬¦ä¸² "ANNIBALE"ã€‚è¿™ä¸ªèŠ‚ç‚¹æŒ‡å‘å¦ä¸€ä¸ªå‹ç¼©èŠ‚ç‚¹ã€‚
    - `"ANNIBALE" -> "SCO" -> []`
    - 1ã€æ’å…¥ "ANNIENTARE"
    - 2ã€æ’å…¥ "ANNIBALI"
    - 3ã€æ’å…¥ "AGO"ï¼ˆåŸèŠ‚ç‚¹è¢«è®¾ç½®ä¸º
    - 4ã€æ’å…¥ "CIAO"
    - 5ã€æ’å…¥ "ANNI"

1ã€å‹ç¼©èŠ‚ç‚¹è¢«åˆ†è£‚ä¸º2ä¸ªå‹ç¼©èŠ‚ç‚¹ + 1ä¸ªéå‹ç¼©

```
               |B| -> "ALE" -> "SCO" -> []
     "ANNI" -> |-|
               |E| -> (... continue algo ...) "NTARE" -> []

```

2ã€å‹ç¼©èŠ‚ç‚¹è¢«åˆ†è£‚ä¸º1ä¸ªå‹ç¼©èŠ‚ç‚¹ + 1ä¸ªéå‹ç¼©

```
                  |E| -> "SCO" -> []
     "ANNIBAL" -> |-|
                  |I| -> (... continue algo ...) []
```

3ã€å‹ç¼©èŠ‚ç‚¹è¢«åˆ†è£‚ä¸º2ä¸ªéå‹ç¼©èŠ‚ç‚¹ + 1ä¸ªå‹ç¼©

```
            |N| -> "NIBALE" -> "SCO" -> []
     |A| -> |-|
            |G| -> (... continue algo ...) |O| -> []
```

4ã€å‹ç¼©èŠ‚ç‚¹è¢«åˆ†è£‚ä¸º1ä¸ªéå‹ç¼©èŠ‚ç‚¹ + 1ä¸ªå‹ç¼©

```
     |A| -> "NNIBALE" -> "SCO" -> []
     |-|
     |C| -> (... continue algo ...) "IAO" -> []
```

5ã€å‹ç¼©èŠ‚ç‚¹è¢«åˆ†ç±»ä¸º2ä¸ªå‹ç¼©èŠ‚ç‚¹

```
     "ANNI" -> "BALE" -> "SCO" -> []
```

- æ³¨é‡Šï¼šALGORITHM 1
  - ï¼ˆï¼Œä¾‹å­1åˆ°4ï¼Œæ‰€æœ‰ä¾‹å­ä¸‹ç”±äºå­—ç¬¦ä¸åŒ¹é…è€Œåœæ­¢äºä¸€ä¸ªå‹ç¼©èŠ‚ç‚¹çš„ä¸­é—´ï¼‰For the above cases 1 to 4, that is, all cases where we stopped in the middle of a compressed node for a character mismatch, do:
  - Let `$SPLITPOS` be the zero-based index at which, in the compressed node array of characters, we found the mismatching character. For example if the node contains "ANNIBALE" and we add"ANNIENTARE" the `$SPLITPOS` is 4, that is, the index at which the mismatching character is found.
  - 1ã€ï¼ˆï¼Œä¿å­˜å½“å‰å‹ç¼©èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æŒ‡é’ˆï¼›ï¼‰Save the current compressed node `$NEXT` pointer (the pointer to the child element, that is always present in compressed nodes).  
  - 2ã€ï¼ˆï¼Œåˆ›å»ºâ€œåˆ†è£‚èŠ‚ç‚¹â€ ï¼Ÿï¼Ÿï¼Ÿ ã€‚ã€‚ã€‚ï¼‰ Create "split node" having as child the non common letter at the compressed node. The other non common letter (at the key) will be added later as we continue the normal insertion algorithm at step "6".  
  - 3a. IF `$SPLITPOS` == 0:  ï¼ˆï¼Œè¯´æ˜å‹ç¼©èŠ‚ç‚¹çš„ç¬¬ä¸€ä¸ªå­—ç¬¦å°±ä¸åŒ¹é…ï¼‰
    - ï¼ˆï¼Œä½¿ç”¨åˆ†è£‚èŠ‚ç‚¹æ›¿æ¢æ—§çš„èŠ‚ç‚¹ï¼›ã€‚ã€‚ã€‚ï¼‰Replace the old node with the split node, by copying the auxiliary data if any. Fix parent's reference. Free old node eventually (we still need its data for the next steps of the algorithm).  
  - 3b. IF `$SPLITPOS` != 0: 
    - ï¼ˆï¼Œè£å‰ªå‹ç¼©èŠ‚ç‚¹ï¼ˆé‡åˆ†é…ä¹‹ï¼‰è€Œä½¿å…¶åŒ…å«sposä¸ªå­—ç¬¦ï¼›å¹¶æ”¹å˜å…¶å­èŠ‚ç‚¹æŒ‡é’ˆè€Œé“¾åˆ°åˆ†è£‚èŠ‚ç‚¹ä¸Šï¼›å¦‚æœæ–°çš„å‹ç¼©èŠ‚ç‚¹é•¿åº¦ä¸º1ï¼Œè®¾ç½®å…¶å±æ€§ä¸ºéå‹ç¼©ï¼›ã€‚ã€‚ã€‚ï¼‰Trim the compressed node (reallocating it as well) in order to contain `$splitpos` characters. Change child pointer in order to link to the split node. If new compressed node len is just 1, set iscompr to 0 (layout is the same). Fix parent's reference.
  - 4a. ï¼ˆï¼Œå¦‚æœåç¼€é•¿åº¦ä¸ä¸º0ï¼ˆï¼Œå°±æ˜¯å‹ç¼©èŠ‚ç‚¹å…¶**åˆ†è£‚å­—ç¬¦**ä¹‹åçš„å‰©ä½™å­—ç¬¦ï¼‰ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªâ€œåç¼€èŠ‚ç‚¹â€ã€‚ã€‚ã€‚å…¶å­èŠ‚ç‚¹æŒ‡é’ˆæŒ‡å‘nextæŒ‡é’ˆï¼›ï¼‰IF the postfix len (the length of the remaining string of the original compressed node after the **split character**) is non zero, create a "postfix node". If the postfix node has just one character set iscompr to 0, otherwise iscompr to 1. Set the postfix node child pointer to `$NEXT`.  
  - 4b. ï¼ˆï¼Œå¦‚æœåç¼€é•¿åº¦ä¸º0ï¼Œä½¿ç”¨nextæŒ‡é’ˆä½œä¸ºåç¼€æŒ‡é’ˆï¼‰IF the postfix len is zero, just use `$NEXT`as postfix pointer.  
  - 5ã€ï¼ˆï¼Œåˆ†è£‚èŠ‚ç‚¹çš„ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹æ˜¯åç¼€èŠ‚ç‚¹ï¼‰Set child[0] of split node to postfix node.  
  - 6ã€ï¼ˆï¼Œå°†åˆ†è£‚èŠ‚ç‚¹è®¾ç½®ä¸ºå½“å‰èŠ‚ç‚¹ï¼Œè®¾ç½®å½“å‰ä¸‹æ ‡ä¸ºç¬¬äºŒä¸ªå­—èŠ‚ç‚¹ï¼Œå¹¶ç»§ç»­æ’å…¥ç®—æ³•ï¼›ï¼‰Set the split node as the current node, set current index at child[1] and continue insertion algorithm as usually.
- æ³¨é‡Šï¼šALGORITHM 2
  - For case 5, that is, if we stopped in the middle of a compressed node but no mismatch was found, do: 
  - Let `$SPLITPOS` be the zero-based index at which, in the compressed node array of characters, we stopped iterating because there were no more keys character to match. So in the example of the node "ANNIBALE", adding the string "ANNI", the `$SPLITPOS` is 4.  
  - 1ã€Save the current compressed node `$NEXT `pointer (the pointer to the child element, that is always present in compressed nodes).  
  - 2ã€Create a "postfix node" containing all the characters from `$SPLITPOS` to the end. Use `$NEXT` as the postfix node child pointer. If the postfix node length is 1, set iscompr to 0. Set the node as a key with the associated value of the new inserted key.  
  - 3ã€Trim the current node to contain the first `$SPLITPOS` characters. As usually if the new node length is just 1, set iscompr to 0. Take the iskey / associated value as it was in the original node. Fix the parent's reference.  
  - 4ã€Set the postfix node as the only child pointer of the trimmed node created at step 1.
- IF ç»ˆæ­¢èŠ‚ç‚¹æ˜¯å‹ç¼©çš„ï¼Œå¹¶ä¸”åŒ¹é…çš„é•¿åº¦ä¸ä¸ºæ’å…¥å…ƒç´ é•¿åº¦ï¼š
  - ã€‚ã€‚ã€‚
  - æ­¥éª¤å®Œæˆï¼Œé‡Šæ”¾ç»ˆæ­¢èŠ‚ç‚¹çš„å†…å­˜ã€‚åˆ†è£‚èŠ‚ç‚¹æˆä¸ºç»ˆæ­¢èŠ‚ç‚¹ã€‚
- ELIF ç»ˆæ­¢èŠ‚ç‚¹æ˜¯å‹ç¼©çš„ï¼Œå¹¶ä¸”åŒ¹é…çš„é•¿åº¦ç­‰äºæ’å…¥å…ƒç´ é•¿åº¦ï¼š
  - ã€‚ã€‚ã€‚
- ï¼ˆï¼Œç›®å‰ä½ç½®èµ°åˆ°æœ€è¿œå¤„ï¼Œä½†æ˜¯ä»»ç„¶æœ‰å‰©ä½™çš„å­—ç¬¦ã€‚æˆ‘ä»¬éœ€è¦æ’å…¥ç¼ºå¤±çš„èŠ‚ç‚¹ï¼‰We walked the radix tree as far as we could, but still there are left chars in our string. We need to insert the missing nodes.
  - ã€‚ã€‚ã€‚
- æ’å…¥ç»“æŸï¼Œç»ˆæ­¢èŠ‚ç‚¹è¿›è¡Œreallocï¼Œä¸ºäº†èƒ½å­˜æ”¾ ï¼ˆå‚æ•°ï¼šæ–°çš„æ•°æ®æŒ‡é’ˆï¼‰
- å¦‚æœä¸åŒ…å«keyï¼Œradixæ•°çš„å…ƒç´ çš„ç»Ÿè®¡æ•°æ®++ ï¼ˆï¼Ÿï¼Ÿï¼Ÿ ä»€ä¹ˆæ„æ€ï¼‰
  - è‡ªç­”ï¼šå°±æ˜¯åŸæœ‰èŠ‚ç‚¹ï¼Œå¦‚æœä¸åŒ…å«keyï¼Œè¿™æ¬¡æ’å…¥äº†keyï¼Œæ‰€ä»¥ç»Ÿè®¡æ›´æ–°ã€‚
- ä¿®å¤parentæ•°æ®æŒ‡é’ˆä¸ºå½“å‰ã€‚
- è¿” 1ï¼ˆè¡¨ç¤ºå…ƒç´ æ’å…¥ï¼‰
- OOMï¼š
  - ã€‚ã€‚ã€‚


```
raxGenericInsert
  Ds: é€šç”¨çš„æ’å…¥æ–¹æ³•
  Para:
   raxï¼š
     ã€outã€‘ï¼šæ›´æ–°ç»Ÿè®¡æ•°æ®
   sï¼š æ’å…¥çš„å…ƒç´ ï¼ˆå­—ç¬¦ä¸²ï¼‰
   lenï¼šæ’å…¥å­—ç¬¦ä¸²çš„é•¿åº¦
   dataï¼š æ–°çš„æ•°æ®æŒ‡é’ˆã€‚
   oldï¼šã€outï¼Œnullableã€‘äºŒç»´æŒ‡é’ˆï¼Œç”¨äºå­˜æ”¾æ—§çš„æ•°æ®æŒ‡é’ˆã€‚
   overwriteï¼š å¦‚æœå…ƒç´ å·²ç»å­˜åœ¨ï¼Œå‚æ•°å€¼ä¸º1ï¼Œåˆ™å…³è”çš„æ•°æ®è¢«ç»™å®šå‚æ•°æ›´æ–°
  Ret:
   0: å­˜åœ¨ä¸”è¦†ç›–è¿”0ï¼›
    errnoï¼šã€globalã€‘ï¼Œå¦‚æœå‡ºç°oomï¼Œè®¾ç½®ä¸º ENOMEM
   1ï¼šå…ƒç´ æ’å…¥ï¼ˆElement inserted.ï¼‰

```

##### 4.1 æ¥å£-åŒ…è£…å™¨

- raxInsertï¼šåŒä¸Šï¼Œè¦†ç›–å‚æ•°ä¸º1ï¼Œæ’å…¥å¼ºåˆ¶æ›´æ–°
- raxTryInsertï¼šåŒä¸Šï¼Œè¦†ç›–å‚æ•°ä¸º0ï¼Œä¸æ›´æ–°

#### 5ã€æŸ¥æ‰¾ç±»



#### 6ã€åˆ é™¤

##### raxRemoveChildï¼š

- æ³¨é‡Šï¼šIf parent is a compressed node (having a single child, as for definition of the data structure), the removal of the child consists into turning it into a normal node without children.
- å¦‚æœçˆ¶èŠ‚ç‚¹æ˜¯å‹ç¼©èŠ‚ç‚¹ï¼š
  - åªæ˜¯æŠŠèŠ‚ç‚¹çš„å±æ€§è®¾ç½®ä¸ºä¸ºéå‹ç¼©ï¼Œå¤§å°è®¾ç½®ä¸º0ã€‚
  - å¦‚æœå­˜åœ¨keyï¼Œåˆ™å–å…¶valueã€‚
  - æ³¨æ„ï¼šæ”¹ä¸ºéå‹ç¼©èŠ‚ç‚¹çš„è¿‡ç¨‹ï¼Œå ç”¨å†…å­˜å‡å°‘ï¼Œä¸ä¼šè¿›è¡Œreallocã€‚è€Œæ˜¯é€šè¿‡memcpyå‘å‰ç§»åŠ¨ï¼Œå‰©ä½™ç©ºé—´ä¸ä½¿ç”¨ã€‚
  - å¦‚æœå­˜åœ¨keyï¼Œé‡æ–°è®¾ç½®valueï¼ˆè¿™ä¸ªè¿‡ç¨‹ä¼šè®¡ç®—å¤§å°ï¼Œmemcpyï¼‰
  - è¿”å›çˆ¶èŠ‚ç‚¹ã€‚
- æ³¨é‡Šï¼šï¼ˆå¦åˆ™æˆ‘ä»¬éœ€è¦æ‰«æå‡ºå­èŠ‚ç‚¹çš„ä½ç½®ï¼Œå¯¹åº”åœ°è¿›è¡Œmemmoveï¼‰Otherwise we need to scan for the child pointer and memmove() accordingly.
- 1ã€To start we seek the first element in both the children pointers and **edge bytes** in the node.
  - ç§»åŠ¨åˆ°ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹å’Œé¦–ä¸ªå­—ç¬¦
- 2ã€Search the child pointer to remove inside the array of children pointers.
  - while 1ï¼š
    - memcpyç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä¸ï¼ˆå‚æ•°ï¼šèŠ‚ç‚¹ï¼‰
    - å¦‚æœç›¸åŒbreak
    - å¦åˆ™ï¼ŒæŒ‡é’ˆ++ï¼Œå­—ç¬¦æŒ‡é’ˆ++ã€‚
- 3ã€ï¼ˆï¼Œç§»åŠ¨å­—ç¬¦èŠ‚çš„ä½ç½®ï¼Œå› ä¸ºåˆ é™¤äº†ä¸€ä¸ªå­—èŠ‚ï¼›ï¼‰Remove the edge and the pointer by memmoving the remaining children pointer and edge bytes one position before.
- ï¼ˆï¼Œè®¡ç®—åç§»é‡ï¼‰Compute the shift, that is the amount of bytes we should move our child pointers to the left, <u>since the removal of one edge character and the corresponding padding change, may change the layout.</u> We just check if in the old version of the node there was at the end just a single byte and all padding: in that case removing one char will remove a whole sizeof(void*) word.
  - `size_t shift = ((parent->size+4) % sizeof(void*)) == 1 ? sizeof(void*) : 0;`
  - å¦‚æœå¤´éƒ¨å¤§å° + å­—ç¬¦æ•° çš„å¤§å°å¯¹äºæŒ‡é’ˆå¤§å°å–ä½™æ˜¯1ï¼Œåˆ™è¯´æ˜å‡å»è¿™ä¸ªå­—ç¬¦çš„ï¼Œå®é™…ä¸Šè¦å‡å°‘8ä¸ªbitä½ã€‚
- å¦‚æœå­˜åœ¨å¯¹é½åç§»ï¼š
  - Move the children pointers before the deletion point.
- Move the remaining "tail" pointers at the right position as well.
  - ã€ï¼Ÿï¼Ÿï¼Ÿã€‘ä¸ºä»€ä¹ˆä¸æ˜¯2ä¸ªä¸€èµ·ç§»åŠ¨ï¼Œè€Œè¦åˆ†å¼€ç§»åŠ¨ï¼Ÿ
  - è‡ªç­”ï¼šä»£ç æ²¡æœ‰ä»”ç»†çœ‹ï¼Œå®é™…ä¸Šè¿™é‡Œå°±æ˜¯2ä¸ªä¸€èµ·ç§»åŠ¨ã€‚ä¸Šä¸€æ­¥æ˜¯ä¸ºäº†å¤„ç†å¯¹é½å˜åŒ–çš„åç§»ã€‚
- æ›´çˆ¶èŠ‚ç‚¹çš„å¤§å° - 1
- ï¼ˆï¼Œé‡åˆ†é…èŠ‚ç‚¹çš„å¤§å°ï¼Œå¯ä»¥é‡Šæ”¾å¤šå ç”¨çš„å†…å­˜ï¼‰realloc the node according to the theoretical memory usage, to free data if we are over-allocating right now.
  - å¦‚æœreallocå¤±è´¥ï¼ˆè¿”NULLï¼‰ï¼Œè¿”å›æ—§çš„çˆ¶èŠ‚ç‚¹å³å¯ã€‚

```
raxRemoveChildï¼š
  Dsï¼šç§»é™¤çˆ¶èŠ‚ç‚¹ä¸Šçš„å­èŠ‚ç‚¹
    type: [low level function] ä½å±‚çº§å‡½æ•°
    Noteï¼šä¸ä¼šå› ä¸ºOOMè€Œå¤±è´¥
  Callerï¼š
    ï¼ˆï¼Œä¸ä¼šä¿®å¤çˆ¶èŠ‚ç‚¹åœ¨å…¶çˆ¶äº²ä¸Šçš„å¼•ç”¨ä½ç½®ï¼‰Note that this function does not fix the pointer of the parent node in its parent, so this task is up to the caller. 
  Paraï¼š
    parentï¼šçˆ¶èŠ‚ç‚¹
    childï¼šè¢«åˆ é™¤çš„å­èŠ‚ç‚¹
       Convention: å¦‚æœçˆ¶èŠ‚ç‚¹æ˜¯éå‹ç¼©èŠ‚ç‚¹ï¼Œåˆ™å‚æ•°childï¼Œå¿…é¡»å­˜åœ¨äºçˆ¶èŠ‚ç‚¹ã€‚å¦åˆ™è¿›å…¥æ­»å¾ªç¯
  Ret: raidxèŠ‚ç‚¹æŒ‡é’ˆ
    1ã€æ–°çš„çˆ¶èŠ‚ç‚¹ï¼ˆå¦‚æœå­èŠ‚ç‚¹åˆ é™¤äº†ï¼‰
    2ã€åŸèŠ‚ç‚¹ï¼ˆæœªåˆ é™¤ï¼‰
```

##### raxRemoveï¼š

- ã€‚ã€‚ã€‚
  - å¦‚æœwalkæŸ¥æ‰¾å‡ºç°ï¼ˆ3ç§æƒ…å†µï¼š1ã€é•¿åº¦ä¸åŒ¹é… 2ã€å‹ç¼©å´ä¸åœ¨èµ·å§‹ä¹‹å‰  3ã€ä¸åŒ…å«keyï¼‰ï¼Œåˆ™ç›´æ¥è¿”å›0ï¼›
- æ³¨é‡Šï¼šIf this node has no children, the deletion needs to reclaim the no longer used nodes. This is an iterative process that needs to walk the three upward, deleting all the nodes with just one child that are not keys, until the head of the rax is reached or the first node with more than one child is found.
- å¦‚æœç»ˆæ­¢èŠ‚ç‚¹æ²¡æœ‰å­èŠ‚ç‚¹ï¼š
  - while ç»ˆæ­¢èŠ‚ç‚¹ä¸æ˜¯radixæ ‘å¤´éƒ¨ï¼š
    - é‡Šæ”¾èŠ‚ç‚¹å†…å­˜
    - radixæ ˆï¼Œå‡ºæ ˆï¼Œç»ˆæ­¢èŠ‚ç‚¹æ›´æ–°
    - If this node has more then one child, or actually holds a key, stop here.ï¼ˆbreaké€€å‡ºï¼‰
  - å¦‚æœchildèŠ‚ç‚¹ä¸ä¸ºnull
    - éœ€è¦å°†å·²åˆ é™¤çš„childï¼Œåœ¨å…¶çˆ¶èŠ‚ç‚¹ä¸Šå»é™¤å¼•ç”¨ã€‚
    - ï¼ˆå‡½æ•°ï¼šraxRemoveChildï¼‰ç§»é™¤
    - å¦‚æœçˆ¶èŠ‚ç‚¹è¢«reallocäº†ï¼š
      - éœ€è¦ä¿®æ”¹çˆ¶çˆ¶èŠ‚ç‚¹çš„å¼•ç”¨
      - peek radixæ ˆï¼Œè·å–çˆ¶çˆ¶èŠ‚ç‚¹ã€‚
      - å¦‚æœä¸ºNULLï¼š
        - è¯´æ˜éœ€è¦æ›´æ–°radixæ ‘çš„headæŒ‡é’ˆ
      - å¦åˆ™ï¼šéœ€è¦findï¼ˆæŸ¥æ‰¾ï¼‰å…·ä½“ä½ç½®
      - é€šè¿‡memcpyå°†æ–°çš„ä½ç½®å¤åˆ¶è¿‡å»ã€‚
    - If after the removal the node has just a single child and is not a key, we need to try to compress it.
- å¦‚æœç»ˆæ­¢èŠ‚ç‚¹æœ‰ä¸€ä¸ªå­èŠ‚ç‚¹ï¼š
  - ï¼ˆï¼Œå¦‚æœè¿™ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œåˆ™æœ‰å¯èƒ½åœ¨ç§»é™¤è¿™ä¸ªèŠ‚ç‚¹çš„keyåï¼Œè¿›ä¸€æ­¥ä¸ç›¸é‚»çš„èŠ‚ç‚¹å‹ç¼©åœ¨ä¸€èµ·ï¼›ï¼‰If the node had just one child, after the removal of the key further compression with adjacent nodes is potentially possible.
- ï¼ˆï¼Œå¼‚å¸¸åœºæ™¯ï¼šã€‚ã€‚ã€‚ï¼‰Don't try node compression if our nodes pointers stack is not complete because of OOM while executing `raxLowWalk()`
- æ³¨é‡Šï¼šé‡å‹ç¼©
  - Recompression: if trycompress is true, 'h' points to a radix tree node that changed in a way that could allow to compress nodes in this sub-branch. Compressed nodes represent chains of nodes that are not keys and have a single child, so there are two deletion events that may alter the tree so that further compression is needed:  
  - 1ã€A node with a single child was a key and now no longer is a key. 
  - 2ã€A node with two children now has just one child.  
  - ï¼ˆï¼Œå°è¯•å‘ä¸Šå¼•å¯¼ç›´åˆ°æœ‰å…¶å®ƒèŠ‚ç‚¹å¯ä»¥è¢«å‹ç¼©ï¼›å½“æˆ‘ä»¬åˆ°äº†ä¸€ä¸ªä¸Šéƒ¨èŠ‚ç‚¹å…¶ä¸æ˜¯ä¸€ä¸ªkeyä¸”æœ‰ä¸€ä¸ªå•ä¸ªå­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬æ‰«æå­èŠ‚ç‚¹é“¾è€Œæœé›†æ ‘çš„å¯å‹ç¼©éƒ¨åˆ†ï¼Œå¹¶æ›¿æ¢å½“å‰èŠ‚ç‚¹ä¸ºæ–°çš„ï¼Œã€‚ã€‚ã€‚ï¼‰We try to navigate upward till there are other nodes that can be compressed, when we reach the upper node which is not a key and has a single child, we scan the chain of children to collect the compressible part of the tree, and replace the current node with the new one, fixing the child pointer to reference the first non compressible node.
- ã€ğŸ¤¢ğŸ¤¢ğŸ¤¢ã€‘
- è¿” 1ï¼›

ä¾‹å­1ï¼š

```
Example of case "1". A tree stores the keys "FOO" = 1 and "FOOBAR" = 2:

"FOO" -> "BAR" -> [] (2)
          (1)
          
After the removal of "FOO" the tree can be compressed as:

"FOOBAR" -> [] (2)
```

ä¾‹å­2ï¼š

```
Example of case "2". A tree stores the keys "FOOBAR" = 1 and "FOOTER" = 2:

         |B| -> "AR" -> [] (1)
"FOO" -> |-|
         |T| -> "ER" -> [] (2)

After the removal of "FOOTER" the resulting tree is:

"FOO" -> |B| -> "AR" -> [] (1)

That can be compressed into:

"FOOBAR" -> [] (1)
```

===

```
raxRemoveï¼š
	Dsï¼šåˆ é™¤æŒ‡å®šçš„å­—ç¬¦é¡¹
	Paraï¼š
	  raxï¼šã€‚ã€‚
	  sï¼šåˆ é™¤çš„å­—ç¬¦é¡¹
	  lenï¼šå­—ç¬¦é•¿åº¦
	  oldï¼šã€outï¼Œnullableã€‘åˆ é™¤çš„æ•°æ®
	Retï¼š
		1ï¼šå­—ç¬¦é¡¹è¢«å‘ç°ï¼Œå¹¶ä¸”åˆ é™¤æˆåŠŸ
		0ï¼šå¦åˆ™ï¼Œè¿”å›0
```



#### 7ã€å†…å­˜é‡Šæ”¾



raxRecursiveFreeï¼š

-  ï¼ˆï¼Œæ‰§è¡Œå¯¹ä¸€ä¸ªæ ‘çš„æ·±åº¦ä¼˜å…ˆï¼Œé€’å½’é‡Šæ”¾å­èŠ‚ç‚¹çš„å†…å­˜ï¼›ï¼‰performs a depth-first scan of the tree and releases all the nodes found.
  - ï¼ˆå‚æ•°ï¼šfree_callbackï¼‰ï¼Œå¦‚æœèŠ‚ç‚¹å­˜åœ¨keyï¼Œåˆ™é€šè¿‡å›è°ƒé‡Šæ”¾valueï¼›

raxFreeï¼š

- ï¼ˆï¼Œé‡Šæ”¾æ•´ä¸ªradixæ ‘ï¼Œæ³¨æ„ï¼Œå…¶æ²¡æœ‰å›è°ƒä¸é‡Šæ”¾è¾…åŠ©æ•°æ®ï¼›ï¼‰Free a whole radix tree.



#### 8ã€ï¼ˆâŒï¼‰è¿­ä»£å™¨ï¼ˆIteratorï¼‰

##### raxIteratorNextStepï¼š

- æ³¨é‡Šï¼š
  - Do an iteration step towards the next element. At the end of the step the iterator key will represent the (new) current key. If it is not possible to step in the specified direction since there are no longer elements, the iterator is flagged with `RAX_ITER_EOF`.  
  - If 'noup' is true the function starts directly scanning for the next lexicographically smaller children, and the current node is already assumed to be the parent of the last key node, so the first operation to go back to the parent will be skipped. This option is used by raxSeek() when implementing seeking a non existing element with the ">" or "<" options: the starting node is not a key in that particular case, so we start the scan from a node that does not represent the key set.

```
raxIteratorNextStepï¼š
  Dsï¼šå®‰è£…å­—æ¯è¡¨é¡ºåºï¼Œå°†è¿­ä»£å™¨ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå…ƒç´ ä½ç½®ã€‚
  Para:
    itï¼š è¿­ä»£å™¨
    noupï¼š
  Retï¼š
  	1ï¼šæˆåŠŸ
  	0ï¼šOOM
```



##### raxSeekGreatest

```
raxSeekGreatestï¼š
  Dsï¼šï¼ˆç§»åŠ¨åˆ°è¿­ä»£å™¨å½“å‰èŠ‚ç‚¹çš„å­æ ‘çš„æœ€å¤§çš„keyï¼‰Seek the greatest key in the subtree at the current node.
  Para:
    it: è¿­ä»£å™¨
  Retï¼š
  	0ï¼šOOM
  	1ï¼šå…¶å®ƒæƒ…å†µ
```

##### raxIteratorPrevStep

```
raxIteratorPrevStepï¼š
	Dsï¼šå®‰è£…å­—æ¯è¡¨é¡ºåºï¼Œå°†è¿­ä»£å™¨ç§»åŠ¨åˆ°ä¸Šä¸€ä¸ªå…ƒç´ ä½ç½®ã€‚
```



##### raxSeek

- é‡ç½®ité‡Œçš„æ ˆçš„æ¸¸æ ‡ä½ç½®ä¸º0ï¼Œè¿­ä»£å™¨æ ‡å‡†æ¸…ç†EOFï¼Œå¹¶è®¾ç½®ä¸ºJUSTï¼›ã€‚ã€‚ã€‚
- ç”±æ“ä½œç¬¦è€Œè®¾ç½®æ ‡å¿—ä½ï¼Œç”¨äºæ‰§è¡Œseek
- å¦‚æœradixæ ‘çš„å…ƒç´ ä¸ªæ•°ä¸º0 ï¼š
  - If there are no elements, set the EOF condition immediately and return
  - è¿” 1
- ã€‚ã€‚ã€‚

```
raxSeekï¼š
	Dsï¼šSeek an iterator at the specified element.
	Paraï¼š
	  itï¼šè¿­ä»£å™¨
	  opï¼šæ“ä½œç¬¦ï¼Œç±»å‹æœ‰ï¼š '>', '>=', '<', '<=', '=', '^', '$'
	  eleï¼š
	  lenï¼š
    Retï¼š
      0ï¼š
        OOMï¼šè®¾ç½®errno
        Syntax error
      1ï¼š others
```



#### 9ã€ï¼ˆâŒï¼‰è‡ªæ£€ï¼ˆIntrospectionï¼‰

## ä¸‰ã€Dict

### 3.1 ç»“æ„ä½“

#### 1ã€å­—å…¸ç±»å‹

dictTypeï¼š

- å›è°ƒå‡½æ•°ï¼ˆæŒ‡é’ˆï¼‰ï¼šCallbacks
  - å“ˆå¸Œå‡½æ•°æŒ‡é’ˆï¼š` uint64_t (*hashFunction)(const void *key);`
  - ã€ğŸ¤¢ğŸ¤¢ğŸ¤¢ã€‘
  - dictMetadataBytesï¼šè¿”å›å­—å…¸é¢å¤–å…ƒæ•°æ®çš„å¤§å°ï¼ˆåˆ›å»ºAPIï¼Œä¼šç½®0ï¼‰
- æ•°æ®ï¼šData
  - userdataï¼šæŒ‡é’ˆ-æŒ‡å‘ç”¨æˆ·æ•°æ®ã€‚
- æ ‡å¿—ä½ï¼šFlags
  - no_valueï¼šThe 'no_value' flag, if set, indicates that values are not used, i.e. the dict is a set. When this flag is set, it's not possible to access the value of a dictEntry and it's also impossible to use dictSetKey(). Entry metadata can also not be used.
  - keys_are_oddï¼šã€‚ã€‚ã€‚
- å¯æ”¯æŒç‰¹æ€§ï¼ˆfeatureï¼‰ï¼šé»˜è®¤è®¾ç½®NULL
  - ã€ğŸ¤¢ğŸ¤¢ğŸ¤¢ã€‘
- å¯é€‰å›è°ƒå‡½æ•°ï¼šOptional callback
  - ã€ğŸ¤¢ğŸ¤¢ğŸ¤¢ã€‘



#### 2ã€å­—å…¸é¡¹

dictEntryï¼š

- keyï¼škeyæŒ‡é’ˆ
- vï¼švalueè”åˆä½“ï¼Œå¯ä»¥å­˜æ”¾æŒ‡é’ˆï¼Œ64ä½æ•´æ•°ï¼Œæˆ–æµ®ç‚¹æ•°
  - valï¼šæŒ‡é’ˆ
  - u64ã€s64
  - d
- nextï¼šï¼ˆï¼Œåœ¨ç›¸åŒå“ˆå¸Œæ¡¶ä¹‹ä¸‹çš„ä¸‹ä¸€é¡¹ï¼‰Next entry in the same hash bucket.

dictEntryNoValueï¼šåŒä¸Šï¼Œä½†æ˜¯æ²¡æœ‰valueï¼›

#### 3ã€å­—å…¸

dictï¼š

- typeï¼šå­—å…¸ç±»å‹
- `ht_table[2]`ï¼šé¡¹çš„äºŒç»´æŒ‡é’ˆ
- ht_used[2]ï¼šã€‚ã€‚ã€‚
- rehashidxï¼šï¼ˆï¼Œæ ‡å¿—ï¼‰rehashing not in progress if rehashidx == -1
- ã€‚ã€‚ã€‚
- `ht_size_exp[2]`ï¼šï¼ˆï¼Œhasbè¡¨å¤§å°çš„å¹‚ï¼‰exponent of size. (`size = 1<<exp`)
- pauseAutoResizeï¼š
  - If >0 automatic resizing is disallowed
  - 0ï¼šallow
  - <0 indicates coding error
- metadataï¼šæŸ”æ€§æ•°ç»„

#### 4ã€è¿­ä»£å™¨

dictIteratorï¼š

- // If safe is set to 1 this is a safe iterator, that means, you can call dictAdd, dictFind, and other functions against the dictionary even while iterating. Otherwise it is a non safe iterator, and only dictNext() should be called while iterating.\
- dï¼šå­—å…¸
- indexï¼šå½“å‰ä¸‹æ ‡
- tableï¼š
- safeï¼š
  - 1ï¼šå®‰å…¨
  - å…¶å®ƒï¼šä¸å®‰å…¨
- entryï¼š
- nextEntryï¼š
- fingerprintï¼šunsafe iterator fingerprint for misuse detection.



### 3.2 API



```
dictCreateï¼š
  Dsï¼šåˆ›å»ºä¸€ä¸ªæ–°çš„hashè¡¨
  Paraï¼š
    typeï¼š åˆ›å»ºçš„å­—å…¸ç±»å‹
  Retï¼šå­—å…¸å¯¹è±¡
     é¢å¤–æ•°æ®ç½®0
     reset å“ˆå¸Œè¡¨å‚æ•°
     åˆå§‹åŒ–ç»“æ„ä½“
```



```
dictTypeAddMetaï¼š
   Dsï¼šChange dictType of dict to another one with metadata support Rest of dictType's values must stay the same
   Paraï¼š
     dï¼šå­—å…¸äºŒç»´æŒ‡é’ˆ
      outï¼š 
       å­—å…¸å¯¹è±¡è¢«realloc
       è®¾ç½®æ–°çš„å­—å…¸ç±»å‹
      çº¦æŸï¼š æ—§çš„å­—å…¸æ²¡æœ‰å…ƒæ•°æ®
     typeWithMetaï¼š
       assertï¼šä¸æ—§çš„ç±»å‹ï¼Œé™¤å…ƒæ•°æ®å¤§å°å‡½æ•°ï¼Œå’Œå­—å…¸é‡Šæ”¾ä¸Šï¼Œå¿…é¡»memcmpä¸€è‡´
   Retï¼švoid
```



## å››ã€è·³è¡¨ï¼ˆzskiplistï¼‰



zskiplistNodeï¼š

- eleï¼š
- scoreï¼š
- backwardï¼šåå‘æŒ‡é’ˆ
  - å¤´éƒ¨èŠ‚ç‚¹æŒ‡å‘NULL

- `level[]` ï¼šæŸ”æ€§æ•°ç»„ï¼Œè¡¨ç¤ºå…·æœ‰å±‚çº§ã€‚
  - forwardï¼šå‰å‘æŒ‡é’ˆ
  - spanï¼šå‰å‘æŒ‡é’ˆæ‰€æŒ‡å‘çš„å…ƒç´ ä¸å½“å‰ä¹‹é—´çš„è·¨åº¦ã€‚



zskiplistï¼š

- headerï¼šæŒ‡å‘è·³è¡¨çš„å¤´éƒ¨
  - æ³¨ï¼šå¤´éƒ¨æ˜¯ä¸€ä¸ªç‰¹æ®ŠèŠ‚ç‚¹ï¼Œä¸å­˜æ”¾å…·ä½“æ•°æ®ï¼Œåˆå§‹åŒ–è·³è¡¨å°±å­˜åœ¨ã€‚

- tailï¼šæŒ‡å‘è·³è¡¨çš„å°¾éƒ¨
- lengthï¼šè®°å½•è·³è¡¨èŠ‚ç‚¹ä¸ªæ•°ã€‚
- levelï¼šè®°å½•çš„æ˜¯headå¤´éƒ¨çš„levelåˆ†é…çš„ä¸ªæ•°å—ï¼Ÿ



![img](.img/skip_list.drawio.svg)

### 4.1 å®ä¸å·¥å…·

`ZSKIPLIST_MAXLEVEL`ï¼ˆ32ï¼‰ï¼šè·³è¡¨èƒ½æ”¯æŒçš„æœ€å¤§å±‚çº§ï¼ŒShould be enough for 2^64 elements

`ZSKIPLIST_P`ï¼ˆ0.25ï¼‰ï¼šè·³è¡¨æ¦‚ç‡ï¼ŒSkiplist P = 1/4

zslRandomLevel

- Returns a random level for the new skiplist node we are going to create. The return value of this function is between 1 and `ZSKIPLIST_MAXLEVEL` (both inclusive), with a powerlaw-alike distribution where higher levels are less likely to be returned.
- while  rand  <  æ¦‚ç‡ x  éšæœºæœ€å¤§å€¼æ—¶ï¼š
  - level++
- è¿”å› levelï¼ˆè¿›è¡Œæœ€å¤§å€¼é™åˆ¶ï¼‰

```
zslRandomLevelï¼š
   Retï¼š
     1~32ï¼š æ ¹æ®å¹‚å¾‹çš„æ¦‚ç‡åˆ†å¸ƒè¿”å›ï¼Œé«˜å±‚çº§çš„æ¦‚ç‡ä½ã€‚
```

### 4.2 åˆ›å»º

zslCreate

- åˆ›å»ºè·³è¡¨å¯¹è±¡
- å±‚çº§è®¾ç½®ä¸º1
- é•¿åº¦ä¸º0
- åˆ›å»ºå¤´éƒ¨èŠ‚ç‚¹ï¼ˆæŒ‰æœ€å¤§å±‚çº§ï¼‰
- éå†æœ€å¤§å±‚çº§ï¼š
  - å±‚çº§çš„å‰å‘æŒ‡é’ˆä¸ºNULLï¼Œè·¨åº¦ä¸º0
- å¤´éƒ¨çš„åå‘æŒ‡é’ˆä¸ºNULL
- å°¾éƒ¨ä¸ºNULL



### 4.3 æ’å…¥

![img](.img/skip_list_insert.drawio.svg)

zslInsertï¼š

- åˆ›å»ºï¼ˆå±€éƒ¨æ•°ç»„ï¼ˆæŒ‰æœ€å¤§å±‚çº§ï¼‰ï¼šæ›´æ–°èŠ‚ç‚¹æ•°ç»„ï¼‰ï¼Œç”±äºæ–°çš„èŠ‚ç‚¹æ’å…¥ï¼Œæ’å…¥ä½ç½®çš„å‰åèŠ‚ç‚¹çš„å¼•ç”¨ä½ç½®éƒ½éœ€è¦æ›´æ–°ã€‚
  - æ³¨ï¼šè¿™ä¸ªæ˜¯æŒ‰ç…§**å°çš„ï¼ˆæ’å…¥ç‚¹çš„å·¦è¾¹ï¼‰**ä¸€ä¸ªè®°å½•çš„
- åˆ›å»ºï¼ˆå±€éƒ¨æ•°ç»„ï¼ˆæŒ‰æœ€å¤§å±‚çº§ï¼‰ï¼šæ›´æ–°è·¨åº¦æ•°ç»„ï¼‰
  - æ³¨ï¼š**è¿™ä¸ªæ˜¯å¤´éƒ¨åˆ°å±‚çº§æ›´æ–°èŠ‚ç‚¹ï¼ŒäºŒè€…ä¹‹é—´çš„ç´¯ç§¯è·¨åº¦**ã€‚
- ä»è·³è¡¨çš„å¤´éƒ¨èŠ‚ç‚¹å¼€å§‹ã€‚
- éå†ï¼šä»è·³è¡¨æœ€å¤§å±‚çº§å¼€å§‹å¾€ä¸‹
  - store rank that is crossed to reach the insert position 
    - ï¼ˆï¼Ÿï¼Ÿï¼Ÿ æ›´æ–°è·¨åº¦æ•°ç»„æ²¡æœ‰è¿›è¡Œåˆå§‹åŒ–ï¼Œä¸ºä»€ä¹ˆå¼•ç”¨åä¸€ä¸ªçš„å€¼ï¼‰
      - è‡ªç­”ï¼šå› ä¸ºä¸‹æ ‡æ˜¯å‡å°çš„ï¼Œå¼•ç”¨åä¸€ä¸ªè¡¨ç¤ºä¸Šä¸€è½®æ›´æ–°çš„å€¼ã€‚
    - ï¼Ÿ ä¸ºäº†è¦åŠ ä¸Šä¸€è½®çš„å€¼å‘¢ï¼Ÿ
      - è‡ªç­”ï¼šå› ä¸ºæ›´æ–°èŠ‚ç‚¹ä¼šå‰è¿›ï¼Œè€Œè®°å½•çš„æ˜¯ä»å¤´éƒ¨åˆ°å½“å‰çš„ç´¯ç§¯è·¨åº¦ã€‚
  - while ä¸‹ä¸€è·³ä¸ä¸ºNULLï¼Œä¸”ï¼ˆä¸‹ä¸€è·³çš„åˆ†æ•°å°äº æ’å…¥çš„ï¼›æˆ–è€… ï¼› åˆ†æ•°åŒè€Œå­—ç¬¦å°ï¼‰
    - Noteï¼šè·³è¡¨æ˜¯ä¸€ä¸ªæœ‰åºé“¾è¡¨ï¼Œè¦ç¡®å®šæ’å…¥ä½ç½®ã€‚
    - å½“å‰ä¸‹æ ‡çš„è·¨åº¦   åŠ ä¸Š   å½“å‰èŠ‚ç‚¹çš„æ‰€åœ¨å±‚çº§çš„è·¨åº¦
    - å½“å‰èŠ‚ç‚¹æ›´æ–°ä¸ºä¸‹ä¸€è·³
  - æ›´æ–°èŠ‚ç‚¹æ•°ç»„è®°å½•å½“å‰å±‚çº§çš„æ›´æ–°èŠ‚ç‚¹ä¸ºå½“å‰èŠ‚ç‚¹
- ï¼ˆï¼Œæ³¨æ„ç‚¹ï¼šå¯ä»¥å…è®¸æ’å…¥åˆ†æ•°ç›¸åŒçš„å…ƒç´ ï¼Œä½†æ˜¯ä¸å¯èƒ½å‘ç”Ÿï¼ˆå› ä¸ºï¼šè°ƒç”¨è€…åœ¨å¤–å±‚ä¼šåšæ£€æŸ¥ã€‚ï¼‰ï¼‰we assume the element is not already inside, since we allow duplicated scores, reinserting the same element should never happen since the caller of zslInsert() should test in the hash table if the element is already inside or not.
- è¿”å›æ–°èŠ‚ç‚¹çš„éšæœºå±‚çº§
- å¦‚æœ éšæœºå±‚çº§  >  å¤´éƒ¨å±‚çº§
  - éå†ï¼š å¤§äºå¤´éƒ¨çš„å±‚çº§
    - ï¼ˆæ›´æ–°è·¨åº¦æ•°ç»„ï¼‰è®¾ç½®ä¸º0
    - ï¼ˆæ›´æ–°èŠ‚ç‚¹æ•°ç»„ï¼‰è®¾ç½®ä¸ºå¤´éƒ¨èŠ‚ç‚¹
    - å¤´éƒ¨èŠ‚ç‚¹å¯¹åº”å±‚çº§çš„è·¨åº¦è®¾ç½®ä¸ºè·³è¡¨çš„é•¿åº¦ã€‚ï¼ˆï¼Ÿï¼Ÿï¼Ÿï¼‰
  - è·³è¡¨çš„å±‚çº§æ›´æ–°ä¸º éšæœºå±‚çº§
- åˆ›å»ºæ’å…¥èŠ‚ç‚¹ï¼šåˆ†é…å†…å­˜ã€‚
- éå†ï¼šéšæœºå±‚çº§
  - æ–°èŠ‚ç‚¹å¯¹åº”å±‚çº§çš„å‰ç½®æŒ‡é’ˆ è®¾ç½®ä¸º ï¼ˆæ›´æ–°èŠ‚ç‚¹æ•°ç»„ï¼‰å¯¹åº”å±‚çº§çš„å‰ç½®æŒ‡é’ˆ
  - ï¼ˆæ›´æ–°èŠ‚ç‚¹æ•°ç»„ï¼‰å¯¹åº”å±‚çº§çš„å‰ç½®æŒ‡é’ˆ è®¾ç½®ä¸º  æ–°èŠ‚ç‚¹
  - update span covered by `update[i]` as x is inserted here
    - æ›´æ–°èŠ‚ç‚¹ä¸æ–°èŠ‚ç‚¹éœ€è¦ä¾æ®ï¼ˆæ›´æ–°è·¨åº¦æ•°ç»„ï¼‰è®¾ç½®ã€‚
    - ï¼ï¼ï¼ï¼š ä»”ç»†çœ‹ä¸€éã€‚
- ï¼ˆï¼Œåœºæ™¯ï¼šæ–°èŠ‚ç‚¹çš„å±‚çº§å°ï¼Œæ’å…¥åï¼ŒåŸæœ‰çš„é«˜å±‚çº§è·¨åº¦éœ€è¦æ›´æ–°ï¼‰increment span for untouched levels
  - éå†ï¼š å¤§äºéšæœºå±‚çº§çš„å¤´éƒ¨å±‚çº§
    - å¯¹æ›´æ–°èŠ‚ç‚¹çš„å±‚çº§è·¨åº¦ ++
- è®¾ç½®æ–°èŠ‚ç‚¹çš„åå‘æŒ‡é’ˆ
  - å¦‚æœï¼ˆæ›´æ–°èŠ‚ç‚¹æ•°ç»„ï¼‰çš„ç¬¬ä¸€ä¸ªæ˜¯å¤´éƒ¨ï¼Œåˆ™è¯´æ˜æ’å…¥çš„ä½ç½®æ˜¯ç¬¬ä¸€ä¸ªï¼ˆä¸å­˜åœ¨å‰é¢çš„èŠ‚ç‚¹ï¼‰ï¼Œåå‘æŒ‡é’ˆè¦è®¾ç½®ä¸ºNULL
  - å¦åˆ™ï¼Œè®¾ç½®ä¸º ï¼ˆæ›´æ–°èŠ‚ç‚¹æ•°ç»„ï¼‰çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
- å¦‚æœæ–°èŠ‚ç‚¹çš„ç¬¬ä¸€å±‚çš„å‰å‘æŒ‡é’ˆä¸ä¸ºNULLï¼š
  - åˆ™è¯¥å‰å‘çš„åå‘éœ€è¦æ›´æ–°ï¼Œä¸ºè¿™ä¸ªæ’å…¥çš„èŠ‚ç‚¹
- å¦åˆ™ï¼šè¯´æ˜è¿™ä¸ªèŠ‚ç‚¹æ’å…¥çš„æ˜¯å°¾éƒ¨èŠ‚ç‚¹ 
  - è·³è¡¨çš„å°¾éƒ¨èŠ‚ç‚¹æ›´æ–°ä¸ºæ–°èŠ‚ç‚¹ã€‚
- è·³è¡¨é•¿åº¦++
- è¿”å› æ–°èŠ‚ç‚¹

```
zslInsertï¼š
   Dsï¼šå°†ä¸€ä¸ªåŒ…å«ç»™å®š score å’Œ member çš„æ–°èŠ‚ç‚¹æ·»åŠ åˆ°è·³è¡¨ä¸­
   Paraï¼š
     zslï¼šè·³è¡¨
     scoreï¼šæ’å…¥èŠ‚ç‚¹çš„åˆ†æ•°
     eleï¼šæ’å…¥èŠ‚ç‚¹å­—ç¬¦ä¸²
   Retï¼šæ–°èŠ‚ç‚¹
```



## äº”ã€åŠ¨æ€å­—ç¬¦ä¸²ï¼ˆSDSï¼‰

**Simple dynamic strings**



sdsç±»å‹ï¼š

- typedefï¼š`char *`
- æ³¨ï¼šsdså®é™…æŒ‡å‘ï¼Œå„ç§sdså¤´éƒ¨ç»“æ„ä½“çš„bufä½ç½®ã€‚



sdshdr8ï¼š

- lenï¼š8bit
- allocï¼š8bitï¼Œexcluding the header and null terminator
- flagsï¼š3 lsb of type, 5 unused bits
- bufï¼šæŸ”æ€§æ•°ç»„ï¼Œå®é™…åˆ†é…çš„å­—ç¬¦ä¸²å†…å®¹ã€‚



### 5.0 å‚è€ƒæ–‡ç« 

åœ¨ Redis å†…éƒ¨ï¼Œ å­—ç¬¦ä¸²çš„è¿½åŠ å’Œé•¿åº¦è®¡ç®—å¾ˆå¸¸è§ï¼Œ è€Œ APPEND å’Œ STRLEN æ›´æ˜¯è¿™ä¸¤ç§æ“ä½œï¼Œåœ¨ Redis å‘½ä»¤ä¸­çš„ç›´æ¥æ˜ å°„ï¼Œ è¿™ä¸¤ä¸ªç®€å•çš„æ“ä½œä¸åº”è¯¥æˆä¸ºæ€§èƒ½çš„ç“¶é¢ˆã€‚

å¦å¤–ï¼Œ Redis é™¤äº†å¤„ç† C å­—ç¬¦ä¸²ä¹‹å¤–ï¼Œ è¿˜éœ€è¦å¤„ç†å•çº¯çš„å­—èŠ‚æ•°ç»„ï¼Œ ä»¥åŠæœåŠ¡å™¨åè®®ç­‰å†…å®¹ï¼Œ æ‰€ä»¥ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œ Redis çš„å­—ç¬¦ä¸²è¡¨ç¤ºè¿˜åº”è¯¥æ˜¯**äºŒè¿›åˆ¶å®‰å…¨çš„**ï¼š ç¨‹åºä¸åº”å¯¹å­—ç¬¦ä¸²é‡Œé¢ä¿å­˜çš„æ•°æ®åšä»»ä½•å‡è®¾ï¼Œ æ•°æ®å¯ä»¥æ˜¯ä»¥ `\0` ç»“å°¾çš„ C å­—ç¬¦ä¸²ï¼Œ ä¹Ÿå¯ä»¥æ˜¯å•çº¯çš„å­—èŠ‚æ•°ç»„ï¼Œ æˆ–è€…å…¶ä»–æ ¼å¼çš„æ•°æ®ã€‚

è€ƒè™‘åˆ°è¿™ä¸¤ä¸ªåŸå› ï¼Œ Redis ä½¿ç”¨ sds ç±»å‹æ›¿æ¢äº† C è¯­è¨€çš„é»˜è®¤å­—ç¬¦ä¸²è¡¨ç¤ºï¼š sds æ—¢å¯é«˜æ•ˆåœ°å®ç°è¿½åŠ å’Œé•¿åº¦è®¡ç®—ï¼Œ åŒæ—¶æ˜¯äºŒè¿›åˆ¶å®‰å…¨çš„ã€‚



### 5.1 å·¥å…·å®

SDS_HDRï¼š

- ç›®æ ‡ï¼šä»ç»™å®šå¤§å°ï¼ˆTï¼‰ä¸ sdsæŒ‡é’ˆï¼ˆsï¼‰ï¼Œs å‡å» sdså¤´éƒ¨å¤§å°ï¼Œè€Œå¾—åˆ° sdså¤´éƒ¨æŒ‡é’ˆçš„èµ·å§‹ä½ç½®ã€‚

SDS_HDR_VARï¼šåŒä¸Šï¼Œä½†æ˜¯åˆ†é…äº†ä¸€ä¸ªå¯¹åº”çš„å±€éƒ¨å˜é‡å­˜æ”¾ã€‚

```
#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));
#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))
```



## å…­ã€SipHash





## ä¸ƒã€CRC

XMODEM CRC 16ç®—æ³•ï¼š

- æ ‡å‡†ï¼šCCITT standards

```
Name                       : "XMODEM", also known as "ZMODEM", "CRC-16/ACORN"
Width                      : 16 bit
Poly                       : 1021 (That is actually x^16 + x^12 + x^5 + 1)
Initialization             : 0000
Reflect Input byte         : False
Reflect Output CRC         : False
Xor constant to output CRC : 0000
Output for "123456789"     : 31C3
```



## ä¹ã€quicklist



## åã€å‹ç¼©åˆ—è¡¨ï¼ˆziplistï¼‰



## åä¸€ã€å·¥å…·



## åäºŒã€è¿‡æœŸæ¡¶ï¼ˆEBUCKETSï¼‰







