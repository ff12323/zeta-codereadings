地址：https://course.rs/into-rust.html

其它书籍：

- 《Rust 程序设计语言》



## ch0 记录



概念索引：

- ch02：
  - 2.1：变量绑定、所有权
    - 变量可变性：不可变的、可变的（mut）； 常量(constant)
    - 变量解构
    - 解构式赋值
    - 变量遮蔽(shadowing)
  - 2.2：
    - 显式的类型标注
    - 1：
      - 运算符重载：在复杂类型上定义运算符
    - 2：
      - 单元类型：`()`，是一个零长度的元组； 特点：可用作值用来占位，但完全**不占用**任何内存
      - 发散函数( diverge function )：没有返回值的函数
    - 3：
      - 语句（statement）、表达式（expression）
  - 2.3：
    - 1：
      - 所有权的规则：
      - 浅拷贝(shallow copy)、深拷贝(deep copy)、移动(move)
    - 2：
      - 借用(Borrowing)：获取变量的引用，称之为借用
      - 引用、解引用
      - 不可变引用：`&` 符号即是引用，它们允许你使用值，但是不获取所有权
        - 变量默认不可变一样，引用指向的值默认也是不可变的
      - 可变引用：
        - 同一作用域，特定数据只能有一个可变引用
        - 可变引用与不可变引用不能同时存在
      - NIL：Non-Lexical Lifetimes(NLL)，编译器优化的行为，专门用于找到某个引用在作用域(`}`)结束前就不再被使用的代码位置；
      - 悬垂引用(Dangling References)：在 Rust 中编译器可以确保引用永远也不会变成悬垂状态，当你获取数据的引用后，<font color="#F9DDA2">编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用</font>。
  - 2.4：
    - 3：元组结构体(Tuple Struct)、单元结构体(Unit-like Struct)、`#[derive(Debug)]`
      - ` dbg! 宏`：`stderr`，取走所有权 && 返回所有权
    - 4：
      - 枚举(enum）、**枚举类型** 、枚举值
      - Option 与 None
  - 2.6：
    - 【TODO】
  - 2.7：
    - 关联函数：定义在 `impl` 中且没有 `self` 的函数
  - 2.8：
    - 1：泛型参数、结构体泛型
    - 2：
      - 孤儿规则：如果你想要为类型 A 实现特征 T，那么 A 或者 T 至少有一个是在当前作用域中定义的！
      - 特征约束(trait bound)
    - 3：
      - 特征对象：`Box<dyn XXX>` 、 `&dyn XXX`
      - 静态分发(static dispatch)、动态分发(dynamic dispatch)
      - 特征对象的2个限制
    - 4：
      - 关联类型（优点：增加可读性）、运算符重载、完全限定语法、supertrait 
      - newtype 模式：为一个元组结构体创建新类型
  - 2.10：
    - 函数或者方法中，参数的生命周期被称为 `输入生命周期`，返回值的生命周期被称为 `输出生命周期`

第一次阅读：

- ch02：
  - 2.2：
    - Rust 是一门**静态类型**语言
    - Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型；但在某些情况下，它无法推导出变量类型
    - 1：
      - 当在 debug 模式编译时，Rust 会检查整型溢出，存在则使程序在编译时 *panic* (崩溃）
      - 在release 模式构建时，Rust **不**检测整数溢出。Rust 会按照补码循环溢出（*two’s complement wrapping*）
    - 3：
      - Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值
      - 表达式如果不返回任何值，会隐式地返回一个 `()`
      - 表达式会进行求值，然后返回一个值
      - 调用一个函数是表达式，因为会返回一个值；调用宏也是表达式；用花括号包裹最终返回一个值的语句块也是表达式；**总之，能返回值，它就是表达式**:
    - 4：
      - Rust 是**强类型语言**，需要对每一个函数参数都标识出它的具体类型
      - 发散函数( diverge function )：panic函数、无限循环函数
  - 2.3：
    - 1：
      - 首先，**Rust 永远也不会自动创建数据的 “深拷贝”**。因此，任何**自动**的复制都不是深拷贝，可以被认为对运行时性能影响较小。
      - 在堆上的变量，进行变量绑定，会发送移动（move），旧的变量不可再用。
      - 在栈上的变量，进行变量绑定，会发送 deep copy，旧的变量可以再用。（`Copy` 的特征）
        - 元组，当且仅当其包含的类型也都是 `Copy` 的时候；
        - 不可变引用 `&T` ；注意: 可变引用 `&mut T` 是不可以 Copy的
      - 将值传递给函数，或则值从函数返回，会发生所有权的交替；
    - 2：
      - 注意：
        - 1、引用的作用域 `s` 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 `}`
        - 2、Rust 的编译器一直在优化，**早期的时候，引用的作用域跟变量作用域是一致的**，这对日常使用带来了很大的困扰；
  - 2.8：
    - 1：
      - 泛型的优点：Rust 通过在编译时进行泛型代码的 **单态化**(*monomorphization*) 来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。
      - 泛型的缺点：损失了编译速度和增大了最终生成文件的大小
  - 2.11：
    - 2：
      - 传播错误：一个设计良好的程序，一个功能涉及十几层的函数调用都有可能。而错误处理也往往不是哪里调用出错，就在哪里处理，实际应用中，大概率会<font color="#F9DDA2">把错误层层上传然后交给调用链的**上游函数**进行处理</font>，错误传播将极为常见







1、动态数组里的字符串，无法被borrow，缺少 "Copy" 特征

```rust
let args: Vec<String> = env::args().collect();

error[E0507]: cannot move out of index of `Vec<String>`
 --> src\main.rs:8:14
  |
8 |     let a2 = args[2]
  |              ^^^^^^^ move occurs because value has type `String`, which does not implement the `Copy` trait
```





